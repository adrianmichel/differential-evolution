<html>
  <head>
    <title></title>
    <meta content="text/html; charset=unicode" http-equiv="Content-Type"/>
    <meta name="generator" content="CoffeeCup HTML Editor (www.coffeecup.com)"/>
  </head>
  <body>
    <h3>
      <h2>Introduction</h2>
    </h3>Differential Evolution (DE) is a population based stochastic function optimizer algorithm developed by Kenneth Price and Rainer Storn in the 1990s. For detailed information on DE consult any of the numerous online or in print resources listed at the DE homepage&nbsp;<a href="http://www.icsi.berkeley.edu/~storn/code.html">http://www.icsi.berkeley.edu/~storn/code.html</a>. <br/><br/>To quote from the Wikipedia page dedicated to DE (<a href="http://en.wikipedia.org/wiki/Differential_evolution">http://en.wikipedia.org/wiki/Differential_evolution</a>): <br/><br/><em>In computer science, differential evolution (DE) is a method that optimizes a problem by iteratively trying to improve a candidate solution with regard to a given measure of quality. Such methods are commonly known as metaheuristics as they make few or no assumptions about the problem being optimized and can search very large spaces of candidate solutions. However, metaheuristics such as DE do not guarantee an optimal solution is ever found.<br/><br/>DE is used for multidimensional real-valued functions but does not use the gradient of the problem being optimized, which means DE does not require for the optimization problem to be differentiable as is required by classic optimization methods such as gradient descent and quasi-newton methods. DE can therefore also be used on optimization problems that are not even continuous, are noisy, change over time, etc.<br/></em><br/><h2>Real use cases</h2><h3>Algorithmic trading systems optimization</h3>This library was initially developed to be used for trading system optimization, and this section shows why.<br/><br/>An algoritmic trading system (TS) can be defined as a set of rules that takes market data as input and generates trading signals as output. These rules are often based on various statistical functions that are applied to stock prices, such as moving averages, standard deviation, which in turn depend on variables like the moving average period etc. <br/><br/>Some believe that a TS may perform better if they are optimized to adapt to current market conditions. To optimize a TS, it will be repeatedly applied to past data using different sets of variable values until the best hypothetical result is obtained for that period. The best parameters then are applied in real time. <br/><br/>Due to the large variables space (total number of distinct variable value sets), exhaustive optimization (EO), which traverses all these sets is usually impractical. For example 4 variables taking 10 distinct values each would require 10000 trading system runs. Other optimization methods may also be hard or impossible to apply due to the nature of the problem and its data.<br/><br/>DE however works well with this type of problem, and could be applied to reduce the explored variable space by orders of magnitude. For example, a DE optimization session could be set for a population of 10 individuals and a maximum number of generations of 20 as termination criteria (please refer to the terminology section for information on these terms). This would require at most 200 system runs, and often less, if other termination criteria is used such as a performance target x% better than a benchmark (S&amp;P500 or other index). One may doubt the fact that DE offers an advantage over EO as the same termination criteria could be used when running exhaustive optimization, which would also limit the number of runs. But the DE algorithm is designed to converge much faster toward an optimium than a method that simply traverses the variables space.<br/><br/>Please note that it is not proven whether this method actually helps improve a trading system performance, the main point being howerver that DE can be used to obtain a good enough value in a reasonable number of tries.<br/><br/><h3>Other uses<br/></h3><br/>A quick Google search will yield many practical application of DE. Here are&nbsp;a few references to&nbsp;such articles just to illustrate the variaty of domains DE is applicable to:<br/><br/><ul>
      <li>
        <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4983300">An evaluation of Differential Evolution in software test data generation</a> </li>
      <li>
        <a href="https://docs.google.com/viewer?url=http%3A%2F%2Fwww.iaeng.org%2Fpublication%2FIMECS2008%2FIMECS2008_pp1773-1778.pdf">Application of Differential Evolution for a Single-Item Resource-Constrained Aggregate Production Planning Problem</a> </li>
      <li>
        <a href="http://www.scirp.org/Journal/PaperInformation.aspx?paperID=2071">Differential Evolution Algorithm with Application to Optimal Operation of Multipurpose Reservoir</a> </li>
      <li>
        <a href="http://www.mendeley.com/research/combined-optimization-using-cultural-and-differential-evolution-application-to-crystal-structure-solution-from-powder-diffraction-data/">Combined optimization using Cultural and Differential Evolution: application to crystal structure solution from powder diffraction data.</a> </li>
      <li>
        <a href="https://docs.google.com/viewer?url=http%3A%2F%2Fncra.ucd.ie%2Fpapers%2FICAI06_GDE.pdf">Grammatical Differential Evolution</a>&nbsp;(used for automatic program generation)<br/><a href="http://digitalcommons.calpoly.edu/cgi/viewcontent.cgi?article=1217&context=eeng_fac">Application of Differential Evolution to Determine the HEPWM Angles of a Three Phase Voltage Source Inverter</a> </li>
    </ul><h2>Target audience</h2>DE can be useful to many involved in scientific or engineering areas such as: chemistry, electronics, physics, agriculture, telecommunications, software&nbsp;engineering&nbsp;etc.<br/><br/>Using the library doesn't require prior understanding of its or DE internals.&nbsp;Developers with average C++ skills should be able to use it &quot;out of the box&quot;. The library provides default behavior or a selection of several pre-defined policy classes, so that those who are not interested in the DE internals will only have to plug-in their objective function, select the DE runtime parameters, build the code and run it.<br/><br/>Those who need more advanced customization of the DE algorithm or are interested in researching DE itself, can create their own implementations of the various classes that control the algorithm behavior.<br/><h2>Rationale</h2>This component&nbsp;is intended to address the need for a standardized generic, portable and efficient C++ DE library that can be easily customized for a variety of domain specific problems. <br/><br/><h2>Features of this implementation</h2><ul>
      <li>Generic - doesn't make assumptions about the OS, environment it's running in or the problem to optimize </li>
      <li>Written in 100% portable C++, with boost and stl as only dependencies </li>
      <li>Header only project </li>
      <li>Modular </li>
      <li>Robust and memory efficient due to extensive use of shared pointers </li>
      <li>Performant thanks to platform independent multi-processing </li>
      <li>Adjustable and extensible through classes that control its behavior </li>
      <li>Easy to integrate with existing objective functions </li>
      <li>Supports several types of variable constraints useful in real life applications </li>
    </ul><h2>Terminology</h2><em>Objective Function</em> - the function to optimize. <br/><br/><em>Cost</em> - numeric output of the objective function for a given set of input variables.<br/><br/><em>Constraint</em> - defines the domain of acceptable values for a variable. For example variables can be of real, integer type with values limited to a specific range. Other types include set, which can only take one of the several values in a set, or Boolean type, which can be true or false (1 or 0).<br/><br/><em>Variable</em> - a value limited by a constraint<br/><br/><em>Individual</em> - member of a population containing a collection of variables (implemented as a vector), each defined by its own constraints, dictated by the nature of the objective function. These values are passed to the objective function during the optimization process in order to calculate the function cost, which is also stored by the individual. Note: DE requires a larger number of variables than used by the objective function. For example if we are optimizing a function in two variables f(x,y), DE may require a vector of 20 total variables for its internal processing.<br/><br/><em>Population</em> - a collection of individuals (implemented as a vector). During the optimization process, the population changes according to mutation algorithms to attempt to generate the optimium individual.<br/><br/><em>Mutation</em> - the process of modifying the variable values according to one of the several mutation algorithms. The mutation algorithms can be tuned with the help of two parameters: weight and crossover. Consult the detailed DE documentation online for more information on these parameters.<br/><br/><em>Selection</em> - the process of selecting the individuals for the next generation, of the best individual for the current generation, and of the best individual for the entire process.<br/><br/><em>Processor</em> - one objective function processing unit. Each processor runs in its own thread on the same computer, but the processor class can be modified to distribute work across multiple computers.&nbsp;Any number of processors can be created and used during an optimization for parallel processing.<br/><br/><em>Generation</em> - one iteration during the optimization process, which transforms one population in a new one, by mutating some of its individuals.<br/><br/><em>Termination</em> - the logic used to determine when the optimization has completed. <h2>The DE Algorithm</h2>The algorithm has been modified somewhat in this implementation to allow for multi-processing and use of policy classes, and this its description. <ol type="1">
      <li>DE starts by creating an initial population, with individuals set to random variable values within the limits defined by their constraints, and then calculates the cost (the objective function value) for those variables for each individual. </li>
      <li>DE then proceeds to iterate through the current population and mutate variables for each individual according to the mutation policy. All the mutated individuals are then pushed into the processing queue. </li>
      <li>The processors now start evaluating the objective function for variables associated with individuals in the processing queue. The result (cost value) is set into each corresponding individual. This continues until the queue is empty. All these individuals are now candidates for the next generation. </li>
      <li>DE now applies the selection policy to choose the individuals that will make it into the next generation, and also of the best individual for the current iteration and for the entire optimization process. The new generation becomes the current generation for the next iteration. There are currently two selection policies for the new generation: <ol type="1">
          <li>Sort the combined populations and select the first N individuals (where N is the population size) for the new population. </li>
          <li>Compare individuals with the same index from the old and candidate generation and pick the best of each for the new generation. </li>
        </ol>Practical tests have shown that 1 allows the optimization to converge to an optimum value faster than 2. </li>
      <li>DE applies the termination policy to determine if it should stop the process. The termination policy can be as simple as comparing the generation number with a constant representing the maximum allowed number of generations. Or it can be more complex, for example by analyzing the trend of best values for each generation and stopping when the best value change is at or below a predefined threshold. </li>
      <li>If the termination criterion has been met, the process stops and the best value returned to the user. Otherwise, the process restarts from 2. with the new generation as the current generation. </li>
    </ol>Note that the the DE efficiency and even ability to converge to an optimum value depend (heavily for some objective functions) on its parameters: number of variables (total, not just the ones required by the objective function), population size, weight and crossover factors, as well as the different policies (mutation, selection, termination). Consult the online resources on this topic to get the most out of DE, and experiment with your own values as well. </body>
</html>